### Brainstorming
- 평범한 재귀 문제이지만 처음에 생각했을 때 공백들을 어떻게 계산해낼까 고민함
- 주어지는 $N$이 항상 일정한 형식이므로 잘 조작하여 `height(==N)`와
  `width`를 미리 구해주고 2차원 vector에 별이 있는 곳만 표시해주기로 함

- 사이즈가 제일 작은 삼각형까지 내려와서 별을 찍도록 재귀를 구현함
- 기준 `x,y`는 삼각형의 가장 꼭대기 점으로 구현


#### 태그
[#재귀](../기본정리/Recursion.md)

#### 오류
*1트 성공* 야호

#### 평가
골드 4로 평가될 정도인가 싶다.
비슷한 문제인데 삼각형만 아닌 문제가 실버 2,3 정도였던 것 같은데..

&rarr; [#별찍기-10](https://www.acmicpc.net/problem/2447)
이 문제를 보니 사각형이 골드 5니까 골드 4는 정당한 것 같다.
**재귀**랑 **분할정복**을 둘 다 써야 하니까 적절한 것 같기도 하다 :)


#### 완성 코드
```cpp
#include <iostream>
#include <vector>
using namespace std;

void recursion(int, int, int,vector<vector<int>>&);

int main()
{
    int height;
    cin >> height;

    int width = height / 3 * 5 + height / 3 - 1;

    vector<vector<int>>graph(height, vector<int>(width, 0));
    // 0으로 초기화 해준 뒤 별이 있을 곳에만 1로 update 해줄 예정

    recursion(0, width / 2, height,graph);

    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            cout << ((graph[i][j]) ? '*' : ' ');
        }
        cout << "\n";
    }

}

void recursion(int x, int y, int level, vector<vector<int>>& graph) {
    if (level == 3) { // 제일 작은 level
        graph[x][y] = 1;
        graph[x + 1][y - 1] = 1;
        graph[x + 1][y + 1] = 1;
        for (int i = 0; i < 5; ++i) graph[x + 2][y - 2 + i] = 1;
    }
    else {
        recursion(x, y, level / 2, graph);
        recursion(x + level / 2, y - level / 2, level / 2, graph);
        recursion(x + level / 2, y + level / 2, level / 2, graph);
    }
}
